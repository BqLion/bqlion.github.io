<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="http://bqlab-pic.test.upcdn.net/myicon.png">
  <link rel="icon" type="image/png" href="http://bqlab-pic.test.upcdn.net/myicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="desc">
  <meta name="author" content="LiuBingqian">
  <meta name="keywords" content="">
  <title>刘秉乾的技术博客 :)</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>LiuBingqian`s Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">主页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">所有文章</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('http://bqlab-pic.test.upcdn.net/index.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fas fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-md">
        <div class="py-5 z-depth-3" id="board">
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                


  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/25/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-1.2%E7%89%B9%E5%BE%81%E7%9F%A2%E9%87%8F%E4%B8%8E%E7%89%B9%E5%BE%81%E7%A9%BA%E9%97%B4/">
        <p class="h4 index-header">模式识别-1.2特征矢量与特征空间</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">1.2特征矢量与特征空间特征矢量对于一个分析对象的n个特征量测量值分别为（x1,x2,x3,x4,x5,x6,x7,……xn），他们构成一个n维特征矢量Xn。X是原对象的一种数学抽象，用来代表原对象，即是原对象的模式。
特征空间对某对象的分类识别是对其模式也就是对其特征矢量进行分类。
各种不同取值的X的全体构成的n维空间被成为特征空间。
随机变量由于量测系统随机因素的影响以及同类不同对象的特征本身就是在特征空间中散布的，同一个对象或同一类对象的特征量测量是随机变量。（对人体这个对象的特征量测量—查血做b超等都是随机变量。量测系统–医学仪器，以及人体这个大样本的特征，都是在特征空间中均匀散布的）。
1.3随机矢量的描述

完全一类模式的类概率密度函数：

</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/25/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB-1.1%E7%BB%AA%E8%AE%BA/">
        <p class="h4 index-header">模式识别-1.1绪论</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">1.1概论模式识别的发展前景：1.智能化
2.机器学习
3.知识发现
模式识别的基本方法：
模式识别的主流技术

统计模式识别
其中统计模式识别是本课程的主要学习内容。它直接利用各类的分布特征，或隐含地利用概率密度函数、后验概率等概念进行分类识别。基本的技术有聚类分析、判别类域代数界面法、统计决策法、最邻近法等。

结构模式识别
结构模式识别是将对象分解为若干个基本单元，结构关系可以用字符串或者图来表示。类似于nlp中对句子的文法分析来进行pos tagging

模糊模式识别
将模式或者模式类作为模糊集，将其属性转换为隶属度，应用隶属函数、模糊关系或者模糊推理进行分类识别

人工神经网络方法
由大量简单的基本神经元相连接所构成的非线性动态系统。在自学习、自组织、联想以及容错等方面能力强。能用于联想、识别和决策。


模式识别的基本原则
没有免费午餐定理
丑小鸭定理
最小描述原理

1.没有免费午餐定理
一般来说，要想提高某方面的性能，那么随之而来的是更大的代价。
比如在一个模式识别的session中可以用两种方法解，分别是简单的线性感知机方法（只适用于线性可分），另一种是位置函数法，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/22/3.%E8%AF%BE%E7%A8%8B/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB_2_%E8%81%9A%E7%B1%BB%E6%A6%82%E8%AE%BA/">
        <p class="h4 index-header">3.课程/模式识别_2_聚类概论</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">#
2.聚类分析聚类分析方法的有效性
选取不当，则分类无效，如下（比如测量是否有肺炎，参数却选取身高体重而非体温肺片）



特征选取不足，如下只选择X2作为特征，只能切分出w1，w2和w3无法分出



特征选择过多可能无益反而有害，增加分析负担并且让分析效果变差
    


聚类应用的四个基本方向
减少数据
数据量过大，使得数据处理十分费力，可以采用聚类分析的方法将数据分成几组可判断的聚类来处理，然后被分开的每一个类被看成是独立的实体来对待。从这个角度看，数据被压缩了。例如我在做toxic比赛的时候，各种毒性评论分别来自于不同的网站，如果嫌数据量过大，就可以把数据按照不同的网站来源做聚类分离，以减小数据的处理压力.

假说生成
在这种情况下，为了推导出数据性质的一些假说，对数据集进行聚类分析。
因此，这里使用聚类作为建立假说的方法，然后使用其他数据集验证这些假说。

假说检验
利用聚类分析来验证指定假说的有效性。
例如，大公司往往在海外投资这个假说需要被验证是否正确，就要对大公司按照规模、海外活跃度、成功完成项目的能力等进行聚类分析。从而来支持这个假说。

基于分组的预测
对现有</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-22&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/20/3.%E8%AF%BE%E7%A8%8B/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB_1_%E6%A6%82%E8%AE%BA/">
        <p class="h4 index-header">3.课程/模式识别_1_概论</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">#
1.统计模式识别与句法模式识别基本概念统计模式识别统计模式识别是目前的模式识别中最重要的一种方法，他的理论基础是概率论和数理统计。
主要方法是线性或者非线性分类，贝叶斯决策，和聚类分析。
主要优点：

比较成熟
有一定的抗噪声能力
模式识别基元能力强

主要缺点：

对结构复杂的模式抽取特征困难
不能反应模式的结构特征，难以描述模式的性质
难以从整体角度考虑识别问题

句法（结构）模式识别句法模式识别又称结构方法或者语言学方法，是模式识别方法的一种。利用结构特征识别基元，然后用基元识别小模式，然后识别大的模式。这种从小往大组装的模式识别方法通常采用树形结构实现，如下是采用结构特征识别基元然后组装为模式的示例：


句法模式识别就是在学习过程中，确定基元与基元之间的关系，识别出景物的方法。
在判决过程中，首先提取基元，识别基元之间的连接关系，使用推断的文法规则做句法分析。若分析成立，则景物属于相应的类型。
句法模式识别的基本方法理论基础：形式语言，自动机技术
主要方法：自动机技术，CYK剖析算法，Early算法，转移图法
句法模式识别的主要优点
识别方便，可以从简单的基元开始
能够反</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-20&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/16/1.%E7%A7%91%E7%A0%94/%E9%98%85%E8%AF%BB%E5%AD%A6%E8%80%85%E4%B8%AA%E4%BA%BA%E5%85%A8%E9%83%A8%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95/">
        <p class="h4 index-header">1.科研/阅读学者个人全部论文的方法</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">阅读学者个人全部论文的方法读人为什么要读人？零散的阅读文献，不能把握一个领域整体发展的脉络。很多时候一个领域的发展是由为数不多的几个科学家或者几个实验室推动的。如果对这些实验室的文章进行系统性的梳理，那么就会在相关领域的发展脉络上有更加深刻的理解。而且通过对这个实验室未来发展方向的预测，这对于我们布局以后的科研方向有很好的促进作用。
以生物界David R Liu为例，演示如何系统性读人，大体分为三个方面：

系统性搜寻文章
文章的阅读与归类
文章的分析和思考

1.1系统性搜寻文章首先找到这个学者的谷歌学术个人首页。个人首页上的文章有两种排序方式，分别是按照引用量排序和按照哦时间序列排序。本文作者推荐使用时间倒序查阅，从当下一直阅读到第一篇博士文章的发表。如下：

谷歌学术镜像站：https://ac.scmor.com/
然后将文章全部下载下来，可以通过endnote，readcube，mendeley等软件实现对文献的管理，作者平常用的是readcube，which will自动标注文章的相关信息。
如下是readcube的示意图：

但是readcube不是免费的，遂下载men</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-16&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/11/0.%E6%A6%82%E5%BF%B5/NLP_Bert%E7%A0%94%E7%A9%B6_WordEmbedding/">
        <p class="h4 index-header">0.概念/NLP_Bert研究_WordEmbedding</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">BERT研究_WordEmbedding本session目的：如下，省略掉Transformer以下所有的模型的冗长发展史直接从Transformer学起。毕竟LSTM也是从更简单的模型发展来的，无限dive一下就到牛三去了。有所取舍cannot agree more。
RNN 和 LSTM都是原始模型，在他们的基础之上改进除了双向LSTM，后边的Attention可以称之为带有注意力的LSTM,其实也就是LSTM的爆改模型。而Transformer则是在Attention之上的更进一步的改装模型。
作者提出观点：希望能够直接认识Transformer和之上的bert，省略掉下面冗长的历史（我同意，毕竟LSTM和RNN也是从别的更原始的数学模型改装来的，无限往下细化就没有尽头了。）

ChrisMcCormickAI认为了解新算法的一般方法
直接找教程、博客文章、原始paper来看。不要硬刚code那样可读性太差。
直接看原始paper，不要无限延伸到其他基础模型。（作者直接调出了bert的paper）


BERT - word embeddingBERT是一个pre-trained</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-11&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/10/0.%E6%A6%82%E5%BF%B5/NLP_GRU_%E4%BB%A3%E7%A0%81_toxic_kaggle/">
        <p class="h4 index-header">0.概念/NLP_GRU_代码_toxic_kaggle</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1"></div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-10&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/09/0.%E6%A6%82%E5%BF%B5/NLP_LSTM_kaggle_toxic%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.概念/NLP_LSTM_kaggle_toxic代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTM模型在kaggle_toxic比赛中的代码实现embedding_matrix = np.zeros((len(word_index) + 1, 300))
for word, i in tqdm(word_index.items()):
    embedding_vector = embeddings_index.get(word)
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector
%%time
with strategy.scope():

    # A simple LSTM with glove embeddings and one dense layer
    model = Sequential()
    model.add(Embedding(len(word_index) + 1,
                     300,
                     weights=[embedding_matrix],
    </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-09&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/07/0.%E6%96%87%E7%AB%A0/%E9%9D%92%E5%B7%A5%E5%A7%94%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0/">
        <p class="h4 index-header">0.文章/青工委论文分享直播笔记</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">青工委论文分享直播笔记1.青工委是国内很强的NLP的学术团体，有刘洋刘知远这种大牛成员。
2.青工委隶属于CIPSC，中国中文信息学会网站：http://www.cipsc.org.cn/
3.认可度高的会议：ACL,IJCAI,SIGIR,AAAI,EMNLP&amp;CIKM:（中了自然有组织找上门）
4.青工委2020学术活动list：

5.青工委学术活跃委员与合作单位list


6.研究前沿：


对话系统和信息抽取是热点研究方向
情感分析都是sentence-level和基于文本推理的

7.机器学习的新的轮子

8.多语言模型是热点（落地意义大）

mBERT Probing
9.多语言论文有29篇：

10.多语言学习论文选读
从结果上来说，有监督学习的效果比无监督学习的效果好。有监督和无监督的2020代表性论文分别是：

无监督学习：
UniTrans
Unsupverised Domain Adaptation


有监督学习：
Bilingual Paraphrase Generation
Multilingual Word Sense Disambiguati</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-07&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_WordEmbedding%E4%BB%A3%E7%A0%81/">
        <p class="h4 index-header">0.概念/NLP_词向量_WordEmbedding代码</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Word_embedding 代码自己定义各个单词的维度是一个工作量巨大、需要深入理解语言内核的工作，而且本工作有很强的复用性。于是不必自己在每一个project中定义各个单词的维度然后算出整个语料库的向量表示，完全可以使用前人算好的结果，比如Glove vector：http://www-nlp.stanford.edu/data/glove.840B.300d.zip 。
其他的选项还有word2vec或者fasttext。
kaggle multi-toxic比赛中用到了glove-840b-300d的word embedding人，如下，读入840-300d的模型，遍历所有的line，输出embedding向量的个数。
# load the GloVe vectors in a dictionary:

embeddings_index = {}
f = open(&#39;/kaggle/input/glove840b300dtxt/glove.840B.300d.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)
for line </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%AE%AD%E7%BB%83%E9%9B%86&%E6%B5%8B%E8%AF%95%E9%9B%86&%E9%AA%8C%E8%AF%81%E9%9B%86&%E6%97%A0%E5%81%8F%E4%BC%B0%E8%AE%A1/">
        <p class="h4 index-header">0.概念/机器学习_训练集&amp;测试集&amp;验证集&amp;无偏估计</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">训练集&amp;测试集&amp;验证集
训练集trian set： 是用来拟合模型的数据集，因为是整体样本数据的一部分，所以虽然他规模最大但是仍然存在有偏估计的问题。
测试集test set：最终模型训练好后，用来提供相对于trian+valid set
validation set：提供相对于训练集的无偏估计的数据集

无偏估计：
当样本分布的平均值等于总体样本的平均值的时候这个估计就是无偏估计。
比如全市十万名小学生的考试成绩的期望（平均值）是60分，那么部分差的小学的平均值就是45分，这个估计就是有偏估计；对全市所有的小学分别随机抽取出100个样本，这个样本的平均值就是60分，和总体十万个样本的平均值相同，这个估计就是无偏估计。
train set 毕竟是整体样本的一部分，不是严格的分层取样所以必然存在有偏估计，validation set就是在train和test上都平均取样的set，解决了有偏估计的问题。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/NLP_LSTM_input&outputShape/">
        <p class="h4 index-header">0.概念/NLP_LSTM_input&amp;outputShape</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTM （RNN）的输入输出形状辨析
在Keras 的LSTM模型中，LSTM的input形状总是一个三维的向量(input_dim,batch_size,time_steps)，如下所示。
建立模型的代码：
model = keras.models.Sequential()
model.add(keras.layer.LSTM(units=3,input_shape=(2,10)))
关于模型summary输出的代码:
model = keras.models.Sequential()
model.add(keras.layers.LSTM(units=3,input_shape(2,10),return_sequences=False))
model.summary()

因为不知道batch_size,所以output shape第一个参数为none，其实应该是(batch_size,3)
总结
LSTM的输入总是一个3D矩阵（batch_size,dim,seq_len）
LSTM的输出是一个2D或者3D矩阵（根据return_sequences不同而有所不同）
If ret</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/05/0.%E6%A6%82%E5%BF%B5/NLP_CNN_padding%E5%A1%AB%E5%85%85/">
        <p class="h4 index-header">0.概念/NLP_CNN_padding填充</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">padding填充padding的CV解释当卷积操作用于图像处理中时，因为卷积窗口总是从图片的左上角滑到右下角，在这个过程中，图片的四条边界区域总是不能位于卷积窗口的中心，于是产生了信息损失，于是将图片的四周填充上空白，这样卷积窗口滑动的时候就能收集到边界的完整信息，如下图所示：

padding的nlp解释通常在业务场景中，CNN网络处理语言文字的时候并不是一次只处理一句话（一条向量），而是成批量的处理例如64句话（64*向量维）的矩阵。因为向量有长有短，矩阵又必须是长方形，于是在缺口的地方都填充上0。
tips：如果将向量的长度进行排序后再批量放到不同的矩阵中，这样不同的矩阵就有不同的大小，减少了对0的处理（本质是浪费）可以提高性能。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-05&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/05/0.%E6%A6%82%E5%BF%B5/NLP_RNN_%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.概念/NLP_RNN_代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">RNN代码实现与注释RNN - recurrent neural network - 循环神经网络，如概念文章所描述，是一个擅长处理序列化数据的网络。
在这个网络中，上一个步骤的输出是下一个步骤的输入，在传统的神经网络中，所有的输入-输出都是彼此的依赖项。
但是在预测下一个词的业务场景中，预测单词需要记住之前的所有词，所以RNN就很适用于这种情况with a help of hidden layer。
这篇代码记录源于kaggle toxic比赛的notebook，代码是有上下文的，代码的上文就是对比赛的train和validate和test数据进行了必要的处理，切分等操作，如下
xtrain, xvalid, ytrain, yvalid = train_test_split(train.comment_text.values, train.toxic.values, 
                                                  stratify=train.toxic.values, 
                            </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-05&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/04/0.%E6%A6%82%E5%BF%B5/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_ConfusedMatrix_%E5%87%86%E7%A1%AE%E7%8E%87&%E5%8F%AC%E5%9B%9E%E7%8E%87&ROC&AUC/">
        <p class="h4 index-header">0.概念/机器学习_ConfusedMatrix_准确率&amp;召回率&amp;ROC&amp;AUC</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Confused Matrix如何衡量一个机器学习模型的效果？不能只看准确率，因为准确率这个评价标准不足以全面评价模型。
先看两个失败的分类模型：
假如意大利展开了新冠肺炎排查行动，暂不管具体是如何排查，输出结果的数学模型是:

把所有人的检测结果都输出为“没有肺炎”，这个时候假设10000个样本，只有2个人得了，准确率高达99.98%，但是这个模型就是个废物，把目的完全丢弃了。
把所有人的检测结果都输出为“有肺炎”，这样能确保阳性样本检出率为100%，但是对所有人都采取隔离措施浪费巨大。这种检测手段也是废物。

几个定义：
上述检测肺炎的例子中，携带病毒为阳性（有敌机，有怀孕），不携带病毒为阴性（气球，无敌机，没怀孕）。把confused matrix画出来如下所示：

更生动的例子：

召回率和准确率一般来说，阳性的例子是检测目标。如果FN假阴性太多，就说这个模型的召回率很低，自然风险控制能力很差（放走了病毒携带者/敌机）。

如果FP假阳性太多，我们就说这种方法的准确率很低，把大量正常人隔离，对假目标比如气球发射导弹。自然这种方法很浪费。

如下所示，召回率（recall）是左侧</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-04&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/04/0.%E6%A6%82%E5%BF%B5/Python_keras_layer%E6%A6%82%E5%86%B5/">
        <p class="h4 index-header">0.概念/Python_keras_layer概况</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_Layerkeras的层包括：
常用层，卷积层，池化层，局部连接层，递归层，嵌入层，高级激活层，规范层，噪声层，包装层，and，也可以编写自己的层。
对于层的通用操作
layer.get_weights()  #返回该层的权重
layer.set_weigths(weights) #将权重加到该层
config = layer.get_config() #保存该层的配置
layer =  layer_from_config(config) # 加载一个配置到该层

#如果该层不是共享层而是一个计算节点，那么可以通过如下方法获得输入、输出张量。输入和输出张量的形状
layer.input
layer.output
layer.input_shape
layer.output_shape

#如果该层有多个计算节点。可以使用下面的方法
layer.get_input_at(node_index)
layer.get_output_at(node_index)
layer.get_input_shape_at(node_index)
layer.get_output_shape_</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-04&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/01/0.%E6%A6%82%E5%BF%B5/Python_Keras_Dense_activation_dropout/">
        <p class="h4 index-header">0.概念/Python_Keras_Dense_activation_dropout</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_常用层常用层对应于core模块，core内部定义了一系列的常用的网络层，包括全连接层和激活层等等。
Dense层keras.layers.core.Dense(units, activation=None, use_bias=True, kernel_initializer=&#39;glorot_uniform&#39;, bias_initializer=&#39;zeros&#39;, kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
Dense层就是常用的全连接层，实现的运算是output = activation(dot(input,kernel)+bias)其中activation是逐元素计算的激活函数，kernel是本层的权值矩阵，bias是偏置向量，只有当use_bias=True才会添加。
如果本层的输入的数据的维度大于2，则会先被压缩成与kernel相匹配的大小。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-01&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/01/0.%E6%A6%82%E5%BF%B5/Python_Keras_Sequential/">
        <p class="h4 index-header">0.概念/Python_Keras_Sequential</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_Sequential开始使用模型顺序模型是多个网络层的线性堆叠。
用户可以通过网络层的实例的列表传递给Sequential的构造器，来创建一个Sequential模型。
from keras.model import Sequential
from keras.layers import Dense,Activation

model = Sequential([
    Dense(32,input_Shape=(784,)),
    Activation(&#39;relu&#39;),
    Dense(10),
    Activation(&#39;softmax&#39;),
])
也可以使用简单的.add()方法将各层添加到模型中
model = Sequential()
model.add(Dense(32,input_dim=784))
model.add(Activation(&#39;relu&#39;))
指定输入数据的尺寸模型需要知道输入尺寸，于是模型的第一层需要明确地被输入数据尺寸（其他层不需要因为可以推测出数据尺寸）。输出尺寸的工作有以下几</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-01&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/31/0.%E6%96%87%E7%AB%A0/Kaggk_toxic_%E4%BB%8ERNN%E5%88%B0Transformer%E5%92%8CBert%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.文章/Kaggk_toxic_从RNN到Transformer和Bert的代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">从0构建：RNN - WE - LSTM&amp;GRU - SEQ2SEQ - Attention - Transformer - BERTTOXIC比赛阐述目的：
测试集来源于wiki讨论区（多语言），输出测试集中每一条评论是否为有毒评论（有毒输1，没毒输0）。
训练集：
前两次比赛的英文数据。
注意点：

有毒是情感分析中专门的一类，要查阅文献了解研究前沿
测试集是跨语言的，怎么处理跨语言。是五种语言分别建模还是都翻译成英语？
Jigsaw的API Perspective可以使用越来越多的语言为有毒评论分类提供服务。据他们自己所说，去年一年该领域从最新的模型创新中获得了令人印象深刻的多语言功能。包括few- and zero-shot learning。

Mr_KnowNothing的Notebook笔记本文如标题所示，包括如下几个内容：

Simple RNN
Word Embedding
LSTM
GRU
Bi - Directional RNN
Encoder - Decoder Model (Seq2Seq)
Attention Models
Transformers </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-31&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/30/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(3)%E5%BA%94%E7%94%A8%E4%B8%8E%E6%94%B9%E8%BF%9B/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(3)应用与改进</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解（应用）Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
NLP:Universal Transformer：此模型结合了transformer结构和RNN中循环归纳的特点，使得transformer结构能够适应更多的NLU问题。改进的结构如下图，主要是引入了Transition Function，我们可以对attention进行多次循环，这一机制被应用到QA，主语推测谓语，缺失单词填充，数字字符串处理等问题中。

BERT:双向Transformer结构，下图是bert与单向Transformer结构的OpenAI GPT、双向独立LSTM的ElMo对比。

CV : 从略</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-30&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/30/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(2)%E8%87%AA%E6%B3%A8%E6%84%8F%E4%B8%8ETransformer/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(2)自注意与Transformer</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
第二部分：自注意力和transformer上文讲解了早期注意力机制与RNN结合，在机器翻译中的效果。RNN由于其顺序结构训练速度常常受到限制。既然注意力机制模型本身可以看到全局信息，那么一个自然的思路是我们能不能去掉RNN，仅仅依赖Attention注意力模型呢？这样训练既可以并行化，同时也拥有全局信息。
本文就讲解Transformer模型，which仅仅依赖于Attention架构。
代码部分的讲解是Tensor2Tensor的源代码
整体模型架构和工作原理如下例句是“I arrived at the bank after crossing the river”.这里的bank指的是河岸还是银行呢，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-30&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/28/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(1)%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%B8%8ERNN/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(1)注意力与RNN</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
第一部分 ：Seq2seq问题中RNN与Attention的结合RNN结构的局限在机翻任务场景中，之前的NMT模型（neural machine translation）中，通常的配置是encoder - decoder结构。即encoder读取输入的句子将其转换成定长向量，然后decoder再将这个向量翻译成相应的目标语言的文字。
通常encoder和decoder都采用RNN结构（例如 gated RNN : LSTM &amp;&amp; GRU)。如下图所示，我们采用encoder RNN将输入语句信息总结到最后一个隐向量中，并将其作为decoder的初始向量。然后decoder会将其解码为目标</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-28&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/27/3.%E8%AF%BE%E7%A8%8B/%E6%B8%85%E5%8D%8E%E8%AF%BE%E8%A1%A8/">
        <p class="h4 index-header">3.课程/清华课表</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">计算机科学与技术系 00240013 计算机辅助设计技术基础 3 学分 48 学时 Fundamentals of Computer Aided Design 本课程坚持基础知识与实践相结合的指导思想，在学习计算机辅助设计的基础知识的同时,学习三维动画软 件的操作与使用。基础知识包括：图形变换、自由曲线曲面造型技术、三维几何造型、真实感图形。应用 软件：3DSMAX 2013 软件的操作。这两部分内容是有机联系的，基础知识对理解 3DSMAX 软件中的基本概 念提供帮助；通过 3DSMAX 软件的操作与实践，能够更好地理解有关基本概念并学习到一门很实用的技术 （三维造型与动画）。本课程的授课特点：1）基础知识课在教室；三维动画课在机房，主要采用案例的教 学方法，边学边练。2） 基础知识与软件学习交错安排。在一学期 16 周中，三维动画课 8 周，基础知识课 6 周，优秀动画作业课堂交流 1 周，节假日 1 周。课程成绩 100 分，由平时成绩（大约 40 分）和大实验作 业（大约 60 分）组成。平时作业主要由课后作业及出勤情况确定；大实验作业题目自选，鼓励多人合作。 提供三维动画软件</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-27&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/27/4.%E5%AE%89%E8%A3%85%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95_hiker/">
        <p class="h4 index-header">4.安装调试记录/博客建站记录_hiker</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">windows环境下使用hexo搭建hiker博客记录搭建步骤
购买域名

github创建个人仓库

安装node.js

安装hexo

推送网站

域名解析

更换主题

更改配置

发布文章

使用图床


1.域名购买godaddy.com: 域名很全但价格较高，首年年费均价￥60左右,往后每年续费￥120左右。
阿里云：价格适中但个性化后缀较少,cc后缀域名无法备案
namesilo.com: 域名较全,价格最低,bqlab.cc十年￥280,最终在此购买。 
在namesilo.com中的Domain manager中将域名DNS服务器修改为：

ns1.alidns.com
ns2.alidns.com
2.github创建仓库仓库名命名为fuzzypw.github.io，亲测改成其他域名网站不能正常访问，
settings，设置custom domain,输入fuzzy.pw
3.安装node.js下载地址：https://nodejs.org/en/download/
安装完成后检测是否成功：node -v
检测npm是否一起安装成功: npm - v
4.安装h</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-27&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/2.%E6%AF%94%E8%B5%9B/%E6%8C%87%E5%AF%BC_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87&%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9&%E8%B6%85%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/">
        <p class="h4 index-header">2.比赛/指导_性能指标&amp;模型选择&amp;超参数设置</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">性能指标 &amp; 模型选择 &amp; 超参数设置已经知道了常用的模型和训练方法。本文主要记录实际应用中对应特定场景选择哪种模型、如何通过收集模型的反馈结果改善模型。
有时候并不需要采用最新最复杂的模型，而是深入理解一些通用的模型，并更好的实际应用到我们处理的具体问题上去。
（和健身同理，卧推后加夹胸超级组、肩推往头顶夹等高端技巧，但训练效果不好；基础动作（屈伸）练扎实，改善基本问题（脊椎旋转、肩胛骨不稳）后，做简单的推肩10kg和侧平举2kg都觉得酸的要死）。
XLM-R就是fancy的训练技巧，基本的LSTM等理解透彻就是基本功扎实后的简单动作。
孰优孰劣pretty obvious
性能指标准确率与召回率
例如罕见病识别问题，我们只需要设计一个模型将所有的样本的结果都判定为“否”，就可以得到99.99%的准确率，但是无意义。于是在不同的场景下对模型的性能指标有不同定义。
准确率与召回率是两个重要的性能指标。
其中准确率 真正例 / (真正例 + 假正例)是模型作出正例判断时的正确率
召回率是 真正例 / (真正例 + 假反例) 是对于所有实际上正确的例，模型检测到的比率
通常</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/2.%E6%AF%94%E8%B5%9B/%E6%8C%87%E5%AF%BC_%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/">
        <p class="h4 index-header">2.比赛/指导_特征提取与特征选择</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">特征提取与特征选择这两者的效果是一样的，都是试图去减少特征数据集中的属性（特征）的数目，但是两者采用的方法不同，
特征提取的方法是通过属性之间的关系，通过组合不同的属性得到新的属性，改变了特征空间
特征选择的方法是选择出特征集的子集，是一种包含的关系，没有改变特征空间
1.2特征提取的主要方法PCA,LDA,SVD等
1.3特征选择的主要方法1.fliter方法
对每个特征打分，即给出每一维的特征赋予权重，该权重代表了特征的重要性，然后根据权重排序。
主要的方法：卡方，信息增益，相关系数
2.Wrapper方法
主要思想：将子集的选择看成一个搜索寻优问题，生成不同的组合，对组合进行评论
可看做一个优化问题，有很多优化算法可供使用
尤其是启发式算法GA，PSO,DE,ABC等等
主要方法：递归特征消除方法
3.Embedded方法
主要思想：在模型既定的情况下，学习出对提高模型准确性最好的属性，即在确定模型的过程中，挑选出哪些对模型训练有重要意义的属性
主要方法：正则化，如岭回归就是在回归的基础上加上了正则化项
1.4总结1.特征提取是从杂乱无章的世界中，去到更高的世界俯瞰原有世界，这时</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/0.%E6%A6%82%E5%BF%B5/%E6%8A%80%E6%9C%AF_Storm/">
        <p class="h4 index-header">0.概念/技术_Storm</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Stormstorm是一个Apache顶级开源项目,用于流计算
流式计算

实时获取/传输/计算/展示数据
代表技术:Flume实时获取,KAFKA实时存储,Storm实时计算,Redis实时缓存,mysql实时存储

批计算

批量获取/传输数据
代表技术:sqoop导入数据,HDFS存储数据,MapReduce计算数据,Hive计算数据

storm和hadoop的区别:

storm用于流计算,数据用网络传进来,处理过的数据放在内存中
hadoop用于批计算,处理的数据保存在文件存放系统中

storm和hadoop的相同点:

编程模型类似
storm                     hadoop
Nimbus                JobTracker
Supervisor         TaskTracker
Worker                  child
topology              job
spout/bolt           mapper/reducer



</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/19/0.%E6%A6%82%E5%BF%B5/NLP_GRU/">
        <p class="h4 index-header">0.概念/NLP_GRU</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Gated RNN : GRULSTM和GRU这两个重要的深度学习模型，几乎所有能看到的所有深度学习论文都是以这两个模型为基础。
GRU模型GRU模型的主要思想是，我们希望能够保存一些记忆，能够捕获一些较长的依赖，需要有一个模型去学习何时以及如何去做，同时还得允许错误消息流转。基于输入，这些流转会向不同的方向以不同的强度传递。
对GRU的介绍从标准的RNN开始
循环神经网络RNN基本上直接计算下一步的隐层，同样的，之前的隐状态会回归给向量，我们不是去计算GRU数值，而是先要计算其中各个门，这些门和h(t)一样，就是一些连续的隐状态长度一致的向量。这些门包括更新门和重置门。
计算更新门时主要是基于当前输入的词向量和隐藏状态

计算重置门方法类似但是使用的是不同的权重

通过一个直观例子来认识重置门的作用：

详细分析上图的公式和重置门的作用：假如这是一个语义的情感分析任务，前边都是对一个电影长篇累牍的剧情讨论，最后一句话是it`s a really boring movie.那么其实只要最后这个boring就OK了，前边的都可以舍弃。所以这里重置门就可以置为0，把计算累计的东西都清理掉，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-19&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/19/0.%E6%A6%82%E5%BF%B5/NLP_LSTM/">
        <p class="h4 index-header">0.概念/NLP_LSTM</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTMLSTM是什么？GRU可以在序列中学习较长的序列连接，另一种允许你很好的处理长距离序列连接的模型就是LSTM—长短时记忆单元，这个模型比GRU更加强大。
LSTM原始论文中采取了大量的篇幅来分析梯度消失的原因，吴恩达不建议读原始论文来了解LSTM的细节。
控制LSTM行为的核心等式

ct，at是维持的状态值（时时更新），u，f，o分别是更新门，遗忘门，输出门。
LSTM的内部结构图：

Runtime LSTM结构图：

如上的红线表示了通过适当地设置了更新们和遗忘门后，一些数据可以长效地被记住的过程。（从左到右一直被维持着。）
朴素RNN与展开是一种处理序列数据的神经网络，某单词根据上下文变化而有不同含义这种任务就适合交给RNN来做。

RNN在时序上展开

LSTM与RNN结构对比长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。
LSTM结构和普通RNN的对比图如下，LSTM有两个传输状态，分别是cell</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-19&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/18/0.%E6%A6%82%E5%BF%B5/NLP_RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">
        <p class="h4 index-header">0.概念/NLP_RNN循环神经网络</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">循环神经网络RNN循环神经网络擅长处理序列化的数据，比如文字序列或者时间序列。
循环神经网络比基本的前馈神经网络强在它可以跨时间序列地共享不同输入序列之间的特征。
之前提到的CNN卷积神经网络也可参数共享，而RNN循环神经网络与之不同的是每一点的输出依赖于之前的结果。
状态机近似表示RNN名字中的recurrent得名于如下图所示的t时刻的状态 依赖于 t - 1时刻的状态 + 输入x。

​              ↑总图                   ↑拆分                                 ↑ t - 1时刻            ↑ t时刻               ↑ t + 1时刻
上图维持的状态h(t)可以看作是之前的向量序列【x1，x2，x3，x4，……，xn】的全体有损表示（损度可控，某些语言模型只有附近的文字重要就可以加大损度）。
RNN基本结构图
如上，x是时时输入的序列，h是维持的状态，o是状态给出的输出，y是训练集中的答案，L是答案和输出之间的损失函数（如交叉熵）。
因为上一个状态h(t-1)和下一个状态ht之间有循环连</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-18&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/17/3.%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_%E6%AD%A3%E4%BA%A4%E5%BD%92%E4%B8%80%E6%80%A7/">
        <p class="h4 index-header">3.课程/线性代数_正交归一性</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">正交归一性如果内积空间的两个向量是互相正交的，并且两个向量的范数都是1，则称这两个向量互相具有正交归一性/正交规范性。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-17&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/17/3.%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_%E5%BD%92%E4%B8%80%E5%8C%96/">
        <p class="h4 index-header">3.课程/线性代数_归一化</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">归一化归一化消除了量纲，是处理数据的一种手段。通过归一化最优解的寻找过程会变得平缓，更容易正确的收敛到最优解。
下图的例子是房价预测模型，横坐标是房间数量（0 - 10），纵坐标是面积大小（0 - 1000），预测结果是等高线上的没画出的第三维。
图一未归一化，图像是长椭圆，图二归一化后是正圆（拍扁了数据），可见归一化后收敛过程更平缓。


</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-17&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/15/0.%E6%96%87%E7%AB%A0/NLP_The%20Annotated%20Transformer/">
        <p class="h4 index-header">0.文章/NLP_The Annotated Transformer</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">The Annotated Transformerharvard nlp 对Transformer论文的逐行注解,原文：http://nlp.seas.harvard.edu/2018/04/03/attention.html
本文在github和谷歌drive上的网址：
https://github.com/harvardnlp/annotated-transformer
https://drive.google.com/file/d/1xQXSv6mtAOLXxEMi8RvaW8TW-7bvYBDF/view
Import lib:import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import math, copy, time
from torch.autograd import Variable
import matplotlib.pyplot as plt
import seaborn
seaborn.set_context(context=&quot;ta</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-15&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/15/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_WordEmbedding%E8%AF%A6%E8%A7%A3/">
        <p class="h4 index-header">0.概念/NLP_词向量_WordEmbedding详解</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Word_embedding独热码的缺点：
它只考虑了单个单词在向量中的作用，而没有考虑词语与词语之间的关系。
如下，有一个训练好的语言模型，要对“I want a glass of orange  ____”进行识别，并预测接下来的词，那么独热码就不能知道apple 和 orange之间的词义相近性，于是不能在算法习得了I want a glass of orange juice之后，泛化地预测 I want a glass of apple juice，这是因为orange和apple在独热码中的编码是完全随机的，并没有因为词性相近就结构也相近，456和6257的位置并没有章法（随机或者按照词频分布），并且由于独热码的结构特殊性，任何两个独热向量相乘的结果都是0。
特征化表示：
所以自然地，我们使用这些词的特征化表示，比如把性别作为一个维度来度量这些词，男的是-1，女的是1，然后king就可以是-0.95,queen就是0.97，橘子和苹果就是基本性别中性的词。另一个维度是有多高贵，明显king和queen是高贵的词而apple和orange的高贵属性为接近0的数字。

如下是对词</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-15&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/14/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_SkipGram/">
        <p class="h4 index-header">0.概念/NLP_词向量_SkipGram</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">skip-gram算法详解Skip-gram算法是word2vec模型中两大生成词向量算法中的一个。
生成词汇向量的skip-gram算法的中心思想：给定中心词汇，预测单词们出现在它周围的概率，最终确定的这些单词们，要使概率分布值最大化。
如下，中心词是banking，Skip - gram会尝试去预测它一定范围内（m window）的上下文词汇。

Skip-gram的损失函数损失函数J`(θ)表示的是：一串很长的文本比如整个维基百科（which has足够长的词汇序列和足够多的词汇和真正的行文）然后遍历文本中的所有位置，对于每个位置，我们都会定义一个围绕输入词汇的大小为2m的窗口，窗口包括前后各m个单词，把每个词汇和周围的窗口的p(周围每一个词|中心词)都连乘起来。
这就是一个有监督学习，目标是使损失函数最小化，手段是通过对训练集的training动态调整模型的超参数们(窗口大小，容差系数等).

损失函数plus : 计算机中大量连乘容易误差累计和误差消失，给上边的损失函数整体套上log，将连乘转换为带log的连加。如下
要不是高中学的明白根本肝不到这里……answer the </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-14&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/13/0.%E6%96%87%E7%AB%A0/NLP_word2vec%E5%BA%94%E7%94%A8/">
        <p class="h4 index-header">0.文章/NLP_word2vec应用</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">word2vec应用读取数据import pandas as pd

# Read data from files 
train = pd.read_csv( &quot;labeledTrainData.tsv&quot;, header=0, 
 delimiter=&quot;\t&quot;, quoting=3 )
test = pd.read_csv( &quot;testData.tsv&quot;, header=0, delimiter=&quot;\t&quot;, quoting=3 )
unlabeled_train = pd.read_csv( &quot;unlabeledTrainData.tsv&quot;, header=0, 
 delimiter=&quot;\t&quot;, quoting=3 )

# Verify the number of reviews that were read (100,000 in total)
print (&quot;Read %d labeled train reviews, %d labeled test</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-13&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/">
        <p class="h4 index-header">0.概念/NLP_神经网络和反向传播算法</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">神经网络神经网络深入学习的网站：neuralnetworksanddeeplearning.com 
神经网络就是一个函数，本例中有764个输入，有10个输出 
总览图:
第一层(764)：
764个输入源于28 * 28的正方形格子，每个小格子都是0到1之间的值，越接近1就越白，越接近0就越黑。
隐藏层
隐藏层是干什么的？ 大体上说，隐藏层用于发掘模式。如上所示，隐藏层一识别小线段，隐藏层二识别小线段构成层的圈或者大线段
从这里看出深度神经网络其实就是模式识别的高级应用，所以要恶补pattern recognition。
如何训练神经网络？ 训练神经网络就是把训练集中的数据和label在神经网络中的(784 * 16 + 16 * 16 + 16 * 10) + (16+16+10) =13002    个参数通过动态调整来拟合。
从数学上来说，动态调整13002个参数以获得min(代价函数)的做法，本质上就是寻找函数的最小值，如下

w1和a1： 
a1就是输入的784个点中第一个点的亮暗情况
w1就是接受这第一个点a1刺激的第一层的第一个神经元对第二层的如图所示的神经元的兴奋程度</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/">
        <p class="h4 index-header">0.概念/NLP_随机森林</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">随机森林随机森林就是用随机的方法建立一堆决策树。每棵树之间是没有关联的，当一个待分类样本输入森林中时，将此样本输入进每一个决策树然后看哪种分类结果最多，就最终输出哪种分类结果。
随机森林的构造过程：

假设有N个样本，有放回的随机选择N个样本，然后按照这N个样本训练一个决策树，这N个样本就是决策树根节点的样本
当每个样本有M个属性时，就需要在决策树中分裂节点以做进一步的判断。于是从M中随机选出m个(m &lt;&lt; M)个属性，然后从m个属性中采取某种策略（比如min信息熵）来选择一个属性来作为该节点的分裂属性。
然后就是重复上边的步骤。当下一次分裂选出来的属性还是父节点的属性时，说明已经穷尽属性，到达叶子节点。

按照如上三个步骤，可以构造大量决策树，例如movie sentiment tutor step1中的随机森林就是构造了100颗决策树。
注意：随机森林中的决策树并没有为了回避过拟合问题而剪枝，因为随机采样已经避免了过拟合。
此算法优点：

数据上表现好，两个随机性的引入避免了过拟合问题
抗噪声
能处理高维度数据，而且不用做特征选择。
对数据集的适应能力强，既能处理连续性</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E5%86%B3%E7%AD%96%E6%A0%91/">
        <p class="h4 index-header">0.概念/NLP_决策树</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">决策树决策树是一种树形结构分类器。每个节点都有一个表示属性的判断，每个分支都代表了一个判断结果的输出。
常见的决策树生成算法有ID3,C4.5,C5.0,CART等。
示例：如下图片是正确的分类集（train set）

如下是分类树的判断过程（演示了分类树其实可以有不同构型）


如上分类树的根节点都是判断分数是否大于A（90），如果是就是好学生。然后第二个节点就出现了不同，分别是判断分数是否小于70 OR 出勤率是否大于0.8。
这个分类器节点的构造其实很灵活，怎样构造最好的分类器呢？ID3,ID4.5算法都是倾向于迭代选择熵值最小化的那个分类器。但是ID3,ID4.5算法都有严重的过拟合问题。
CART算法也使用了类似熵的指数–GINI指数，CART算法迭代的目标也是向着GINI指数最小化的方向进行，不过CART算法为了解决过拟合的问题，使用了剪枝的策略，也就是将树中过长的枝叶剪去。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_%E8%AF%8D%E8%A2%8BBOW/">
        <p class="h4 index-header">0.概念/NLP_词向量_词袋BOW</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">词袋算法详解词袋算法是word2vec中构建两大构建词向量算法中的一个。
kaggle tutor实战解读：具体操作如下：

清洗整个语料库by美丽汤
去掉停止词和非英语单词，去掉数组，大小写统一by正则表达式
将剩下的单词组成词典
词典按照词频降序排列
然后指定词袋的feature个数，以五千为例就是前5000个常用单词作为每一个词语/句子的向量表示。
每个向量都是5000维，第一维就是最常用的单词，第二维就是第二常用的单词，第一维是1说明被本向量表示的句子中最常用的单词出现了一次，第一维是2说明被表示的句子中最常用的单词出现了两次。


然后可以将例如25000条语料依次分别按照5000维的向量表示，集合到shape(25000 * 5000)的矩阵中

然后此矩阵带上label就可以用来训练model了
CS224N解读词袋的训练模型如下。

输入层：上下文的独热码，假设向量空间V维，上下文单词个数是C。

所有onehot分别乘以共享的W（V*N）初始化权重矩阵，V是向量维度，N自己设置。

因为是onehot向量，只有一个值为1，其他都是0，所以乘以权重矩阵后仍然是向量，然后</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>



  <nav aria-label="index posts navigation">
    <span class="pagination pg-blue justify-content-center mt-5" id="pagination">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-double-right"></i></a>
    </span>
  </nav>
  
  <script>
    for (ele of document.getElementById("pagination").getElementsByClassName("page-number")) {
      ele.href += '#board';
    }
  </script>



              </div>
            </div>
          </div>
        </div>
      </div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>






  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "暗影疾行&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 120,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
