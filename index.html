<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="http://bqlab-pic.test.upcdn.net/myicon.png">
  <link rel="icon" type="image/png" href="http://bqlab-pic.test.upcdn.net/myicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="desc">
  <meta name="author" content="LiuBingqian">
  <meta name="keywords" content="">
  <title>刘秉乾的技术博客 :)</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 100vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>LiuBingqian`s Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">主页</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">所有文章</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('http://bqlab-pic.test.upcdn.net/index.jpg')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="fas fa-angle-down scroll-down-arrow"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      <div class="container nopadding-md">
        <div class="py-5 z-depth-3" id="board">
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                


  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/11/0.%E6%A6%82%E5%BF%B5/NLP_Bert%E7%A0%94%E7%A9%B6_WordEmbedding/">
        <p class="h4 index-header">0.概念/NLP_Bert研究_WordEmbedding</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">BERT研究_WordEmbedding本session目的：如下，省略掉Transformer以下所有的模型的冗长发展史直接从Transformer学起。毕竟LSTM也是从更简单的模型发展来的，无限dive一下就到牛三去了。有所取舍cannot agree more。
RNN 和 LSTM都是原始模型，在他们的基础之上改进除了双向LSTM，后边的Attention可以称之为带有注意力的LSTM,其实也就是LSTM的爆改模型。而Transformer则是在Attention之上的更进一步的改装模型。
作者提出观点：希望能够直接认识Transformer和之上的bert，省略掉下面冗长的历史（我同意，毕竟LSTM和RNN也是从别的更原始的数学模型改装来的，无限往下细化就没有尽头了。）

ChrisMcCormickAI认为了解新算法的一般方法
直接找教程、博客文章、原始paper来看。不要硬刚code那样可读性太差。
直接看原始paper，不要无限延伸到其他基础模型。（作者直接调出了bert的paper）


BERT - word embeddingBERT是一个pre-trained</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-11&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/10/0.%E6%A6%82%E5%BF%B5/NLP_GRU_%E4%BB%A3%E7%A0%81_toxic_kaggle/">
        <p class="h4 index-header">0.概念/NLP_GRU_代码_toxic_kaggle</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1"></div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-10&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/09/0.%E6%A6%82%E5%BF%B5/NLP_LSTM_kaggle_toxic%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.概念/NLP_LSTM_kaggle_toxic代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTM模型在kaggle_toxic比赛中的代码实现embedding_matrix = np.zeros((len(word_index) + 1, 300))
for word, i in tqdm(word_index.items()):
    embedding_vector = embeddings_index.get(word)
    if embedding_vector is not None:
        embedding_matrix[i] = embedding_vector
%%time
with strategy.scope():

    # A simple LSTM with glove embeddings and one dense layer
    model = Sequential()
    model.add(Embedding(len(word_index) + 1,
                     300,
                     weights=[embedding_matrix],
    </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-09&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/07/0.%E6%96%87%E7%AB%A0/%E9%9D%92%E5%B7%A5%E5%A7%94%E8%AE%BA%E6%96%87%E5%88%86%E4%BA%AB%E7%9B%B4%E6%92%AD%E7%AC%94%E8%AE%B0/">
        <p class="h4 index-header">0.文章/青工委论文分享直播笔记</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">青工委论文分享直播笔记1.青工委是国内很强的NLP的学术团体，有刘洋刘知远这种大牛成员。
2.青工委隶属于CIPSC，中国中文信息学会网站：http://www.cipsc.org.cn/
3.认可度高的会议：ACL,IJCAI,SIGIR,AAAI,EMNLP&amp;CIKM:（中了自然有组织找上门）
4.青工委2020学术活动list：

5.青工委学术活跃委员与合作单位list


6.研究前沿：


对话系统和信息抽取是热点研究方向
情感分析都是sentence-level和基于文本推理的

7.机器学习的新的轮子

8.多语言模型是热点（落地意义大）

mBERT Probing
9.多语言论文有29篇：

10.多语言学习论文选读
从结果上来说，有监督学习的效果比无监督学习的效果好。有监督和无监督的2020代表性论文分别是：

无监督学习：
UniTrans
Unsupverised Domain Adaptation


有监督学习：
Bilingual Paraphrase Generation
Multilingual Word Sense Disambiguati</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-07&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_WordEmbedding%E4%BB%A3%E7%A0%81/">
        <p class="h4 index-header">0.概念/NLP_词向量_WordEmbedding代码</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Word_embedding 代码自己定义各个单词的维度是一个工作量巨大、需要深入理解语言内核的工作，而且本工作有很强的复用性。于是不必自己在每一个project中定义各个单词的维度然后算出整个语料库的向量表示，完全可以使用前人算好的结果，比如Glove vector：http://www-nlp.stanford.edu/data/glove.840B.300d.zip 。
其他的选项还有word2vec或者fasttext。
kaggle multi-toxic比赛中用到了glove-840b-300d的word embedding人，如下，读入840-300d的模型，遍历所有的line，输出embedding向量的个数。
# load the GloVe vectors in a dictionary:

embeddings_index = {}
f = open(&#39;/kaggle/input/glove840b300dtxt/glove.840B.300d.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)
for line </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_%E8%AE%AD%E7%BB%83%E9%9B%86&%E6%B5%8B%E8%AF%95%E9%9B%86&%E9%AA%8C%E8%AF%81%E9%9B%86&%E6%97%A0%E5%81%8F%E4%BC%B0%E8%AE%A1/">
        <p class="h4 index-header">0.概念/机器学习_训练集&amp;测试集&amp;验证集&amp;无偏估计</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">训练集&amp;测试集&amp;验证集
训练集trian set： 是用来拟合模型的数据集，因为是整体样本数据的一部分，所以虽然他规模最大但是仍然存在有偏估计的问题。
测试集test set：最终模型训练好后，用来提供相对于trian+valid set
validation set：提供相对于训练集的无偏估计的数据集

无偏估计：
当样本分布的平均值等于总体样本的平均值的时候这个估计就是无偏估计。
比如全市十万名小学生的考试成绩的期望（平均值）是60分，那么部分差的小学的平均值就是45分，这个估计就是有偏估计；对全市所有的小学分别随机抽取出100个样本，这个样本的平均值就是60分，和总体十万个样本的平均值相同，这个估计就是无偏估计。
train set 毕竟是整体样本的一部分，不是严格的分层取样所以必然存在有偏估计，validation set就是在train和test上都平均取样的set，解决了有偏估计的问题。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/06/0.%E6%A6%82%E5%BF%B5/NLP_LSTM_input&outputShape/">
        <p class="h4 index-header">0.概念/NLP_LSTM_input&amp;outputShape</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTM （RNN）的输入输出形状辨析
在Keras 的LSTM模型中，LSTM的input形状总是一个三维的向量(input_dim,batch_size,time_steps)，如下所示。
建立模型的代码：
model = keras.models.Sequential()
model.add(keras.layer.LSTM(units=3,input_shape=(2,10)))
关于模型summary输出的代码:
model = keras.models.Sequential()
model.add(keras.layers.LSTM(units=3,input_shape(2,10),return_sequences=False))
model.summary()

因为不知道batch_size,所以output shape第一个参数为none，其实应该是(batch_size,3)
总结
LSTM的输入总是一个3D矩阵（batch_size,dim,seq_len）
LSTM的输出是一个2D或者3D矩阵（根据return_sequences不同而有所不同）
If ret</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-06&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/05/0.%E6%A6%82%E5%BF%B5/NLP_CNN_padding%E5%A1%AB%E5%85%85/">
        <p class="h4 index-header">0.概念/NLP_CNN_padding填充</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">padding填充padding的CV解释当卷积操作用于图像处理中时，因为卷积窗口总是从图片的左上角滑到右下角，在这个过程中，图片的四条边界区域总是不能位于卷积窗口的中心，于是产生了信息损失，于是将图片的四周填充上空白，这样卷积窗口滑动的时候就能收集到边界的完整信息，如下图所示：

padding的nlp解释通常在业务场景中，CNN网络处理语言文字的时候并不是一次只处理一句话（一条向量），而是成批量的处理例如64句话（64*向量维）的矩阵。因为向量有长有短，矩阵又必须是长方形，于是在缺口的地方都填充上0。
tips：如果将向量的长度进行排序后再批量放到不同的矩阵中，这样不同的矩阵就有不同的大小，减少了对0的处理（本质是浪费）可以提高性能。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-05&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/05/0.%E6%A6%82%E5%BF%B5/NLP_RNN_%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.概念/NLP_RNN_代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">RNN代码实现与注释RNN - recurrent neural network - 循环神经网络，如概念文章所描述，是一个擅长处理序列化数据的网络。
在这个网络中，上一个步骤的输出是下一个步骤的输入，在传统的神经网络中，所有的输入-输出都是彼此的依赖项。
但是在预测下一个词的业务场景中，预测单词需要记住之前的所有词，所以RNN就很适用于这种情况with a help of hidden layer。
这篇代码记录源于kaggle toxic比赛的notebook，代码是有上下文的，代码的上文就是对比赛的train和validate和test数据进行了必要的处理，切分等操作，如下
xtrain, xvalid, ytrain, yvalid = train_test_split(train.comment_text.values, train.toxic.values, 
                                                  stratify=train.toxic.values, 
                            </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-05&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/04/0.%E6%A6%82%E5%BF%B5/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_ConfusedMatrix_%E5%87%86%E7%A1%AE%E7%8E%87&%E5%8F%AC%E5%9B%9E%E7%8E%87&ROC&AUC/">
        <p class="h4 index-header">0.概念/机器学习_ConfusedMatrix_准确率&amp;召回率&amp;ROC&amp;AUC</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Confused Matrix如何衡量一个机器学习模型的效果？不能只看准确率，因为准确率这个评价标准不足以全面评价模型。
先看两个失败的分类模型：
假如意大利展开了新冠肺炎排查行动，暂不管具体是如何排查，输出结果的数学模型是:

把所有人的检测结果都输出为“没有肺炎”，这个时候假设10000个样本，只有2个人得了，准确率高达99.98%，但是这个模型就是个废物，把目的完全丢弃了。
把所有人的检测结果都输出为“有肺炎”，这样能确保阳性样本检出率为100%，但是对所有人都采取隔离措施浪费巨大。这种检测手段也是废物。

几个定义：
上述检测肺炎的例子中，携带病毒为阳性（有敌机，有怀孕），不携带病毒为阴性（气球，无敌机，没怀孕）。把confused matrix画出来如下所示：

更生动的例子：

召回率和准确率一般来说，阳性的例子是检测目标。如果FN假阴性太多，就说这个模型的召回率很低，自然风险控制能力很差（放走了病毒携带者/敌机）。

如果FP假阳性太多，我们就说这种方法的准确率很低，把大量正常人隔离，对假目标比如气球发射导弹。自然这种方法很浪费。

如下所示，召回率（recall）是左侧</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-04&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/04/0.%E6%A6%82%E5%BF%B5/Python_keras_layer%E6%A6%82%E5%86%B5/">
        <p class="h4 index-header">0.概念/Python_keras_layer概况</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_Layerkeras的层包括：
常用层，卷积层，池化层，局部连接层，递归层，嵌入层，高级激活层，规范层，噪声层，包装层，and，也可以编写自己的层。
对于层的通用操作
layer.get_weights()  #返回该层的权重
layer.set_weigths(weights) #将权重加到该层
config = layer.get_config() #保存该层的配置
layer =  layer_from_config(config) # 加载一个配置到该层

#如果该层不是共享层而是一个计算节点，那么可以通过如下方法获得输入、输出张量。输入和输出张量的形状
layer.input
layer.output
layer.input_shape
layer.output_shape

#如果该层有多个计算节点。可以使用下面的方法
layer.get_input_at(node_index)
layer.get_output_at(node_index)
layer.get_input_shape_at(node_index)
layer.get_output_shape_</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-04&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/01/0.%E6%A6%82%E5%BF%B5/Python_Keras_Dense_activation_dropout/">
        <p class="h4 index-header">0.概念/Python_Keras_Dense_activation_dropout</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_常用层常用层对应于core模块，core内部定义了一系列的常用的网络层，包括全连接层和激活层等等。
Dense层keras.layers.core.Dense(units, activation=None, use_bias=True, kernel_initializer=&#39;glorot_uniform&#39;, bias_initializer=&#39;zeros&#39;, kernel_regularizer=None, bias_regularizer=None, activity_regularizer=None, kernel_constraint=None, bias_constraint=None)
Dense层就是常用的全连接层，实现的运算是output = activation(dot(input,kernel)+bias)其中activation是逐元素计算的激活函数，kernel是本层的权值矩阵，bias是偏置向量，只有当use_bias=True才会添加。
如果本层的输入的数据的维度大于2，则会先被压缩成与kernel相匹配的大小。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-01&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/06/01/0.%E6%A6%82%E5%BF%B5/Python_Keras_Sequential/">
        <p class="h4 index-header">0.概念/Python_Keras_Sequential</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Keras_Sequential开始使用模型顺序模型是多个网络层的线性堆叠。
用户可以通过网络层的实例的列表传递给Sequential的构造器，来创建一个Sequential模型。
from keras.model import Sequential
from keras.layers import Dense,Activation

model = Sequential([
    Dense(32,input_Shape=(784,)),
    Activation(&#39;relu&#39;),
    Dense(10),
    Activation(&#39;softmax&#39;),
])
也可以使用简单的.add()方法将各层添加到模型中
model = Sequential()
model.add(Dense(32,input_dim=784))
model.add(Activation(&#39;relu&#39;))
指定输入数据的尺寸模型需要知道输入尺寸，于是模型的第一层需要明确地被输入数据尺寸（其他层不需要因为可以推测出数据尺寸）。输出尺寸的工作有以下几</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-06-01&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/31/0.%E6%96%87%E7%AB%A0/Kaggk_toxic_%E4%BB%8ERNN%E5%88%B0Transformer%E5%92%8CBert%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">
        <p class="h4 index-header">0.文章/Kaggk_toxic_从RNN到Transformer和Bert的代码实现</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">从0构建：RNN - WE - LSTM&amp;GRU - SEQ2SEQ - Attention - Transformer - BERTTOXIC比赛阐述目的：
测试集来源于wiki讨论区（多语言），输出测试集中每一条评论是否为有毒评论（有毒输1，没毒输0）。
训练集：
前两次比赛的英文数据。
注意点：

有毒是情感分析中专门的一类，要查阅文献了解研究前沿
测试集是跨语言的，怎么处理跨语言。是五种语言分别建模还是都翻译成英语？
Jigsaw的API Perspective可以使用越来越多的语言为有毒评论分类提供服务。据他们自己所说，去年一年该领域从最新的模型创新中获得了令人印象深刻的多语言功能。包括few- and zero-shot learning。

Mr_KnowNothing的Notebook笔记本文如标题所示，包括如下几个内容：

Simple RNN
Word Embedding
LSTM
GRU
Bi - Directional RNN
Encoder - Decoder Model (Seq2Seq)
Attention Models
Transformers </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-31&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/30/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(3)%E5%BA%94%E7%94%A8%E4%B8%8E%E6%94%B9%E8%BF%9B/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(3)应用与改进</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解（应用）Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
NLP:Universal Transformer：此模型结合了transformer结构和RNN中循环归纳的特点，使得transformer结构能够适应更多的NLU问题。改进的结构如下图，主要是引入了Transition Function，我们可以对attention进行多次循环，这一机制被应用到QA，主语推测谓语，缺失单词填充，数字字符串处理等问题中。

BERT:双向Transformer结构，下图是bert与单向Transformer结构的OpenAI GPT、双向独立LSTM的ElMo对比。

CV : 从略</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-30&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/30/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(2)%E8%87%AA%E6%B3%A8%E6%84%8F%E4%B8%8ETransformer/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(2)自注意与Transformer</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
第二部分：自注意力和transformer上文讲解了早期注意力机制与RNN结合，在机器翻译中的效果。RNN由于其顺序结构训练速度常常受到限制。既然注意力机制模型本身可以看到全局信息，那么一个自然的思路是我们能不能去掉RNN，仅仅依赖Attention注意力模型呢？这样训练既可以并行化，同时也拥有全局信息。
本文就讲解Transformer模型，which仅仅依赖于Attention架构。
代码部分的讲解是Tensor2Tensor的源代码
整体模型架构和工作原理如下例句是“I arrived at the bank after crossing the river”.这里的bank指的是河岸还是银行呢，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-30&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/28/0.%E6%A6%82%E5%BF%B5/NLP_%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6Attenion%E8%AF%A6%E7%BB%86(1)%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%B8%8ERNN/">
        <p class="h4 index-header">0.概念/NLP_注意力机制Attenion详细(1)注意力与RNN</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Attention注意力机制详解Attention详解分三篇文章：

Seq2seq问题中RNN与Attention的结合
抛弃RNN的self-Attention模型和Transformer架构
Attention和Transformer在NLP和CV问题上的应用

主要参考资料是Yoshua Bengio组的论文、谷歌研究组的论文、Tensor2Tensor的文档、斯坦福NLP讲义
第一部分 ：Seq2seq问题中RNN与Attention的结合RNN结构的局限在机翻任务场景中，之前的NMT模型（neural machine translation）中，通常的配置是encoder - decoder结构。即encoder读取输入的句子将其转换成定长向量，然后decoder再将这个向量翻译成相应的目标语言的文字。
通常encoder和decoder都采用RNN结构（例如 gated RNN : LSTM &amp;&amp; GRU)。如下图所示，我们采用encoder RNN将输入语句信息总结到最后一个隐向量中，并将其作为decoder的初始向量。然后decoder会将其解码为目标</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-28&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/27/3.%E8%AF%BE%E7%A8%8B/%E6%B8%85%E5%8D%8E%E8%AF%BE%E8%A1%A8/">
        <p class="h4 index-header">3.课程/清华课表</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">计算机科学与技术系 00240013 计算机辅助设计技术基础 3 学分 48 学时 Fundamentals of Computer Aided Design 本课程坚持基础知识与实践相结合的指导思想，在学习计算机辅助设计的基础知识的同时,学习三维动画软 件的操作与使用。基础知识包括：图形变换、自由曲线曲面造型技术、三维几何造型、真实感图形。应用 软件：3DSMAX 2013 软件的操作。这两部分内容是有机联系的，基础知识对理解 3DSMAX 软件中的基本概 念提供帮助；通过 3DSMAX 软件的操作与实践，能够更好地理解有关基本概念并学习到一门很实用的技术 （三维造型与动画）。本课程的授课特点：1）基础知识课在教室；三维动画课在机房，主要采用案例的教 学方法，边学边练。2） 基础知识与软件学习交错安排。在一学期 16 周中，三维动画课 8 周，基础知识课 6 周，优秀动画作业课堂交流 1 周，节假日 1 周。课程成绩 100 分，由平时成绩（大约 40 分）和大实验作 业（大约 60 分）组成。平时作业主要由课后作业及出勤情况确定；大实验作业题目自选，鼓励多人合作。 提供三维动画软件</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-27&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/27/4.%E5%AE%89%E8%A3%85%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95_hiker/">
        <p class="h4 index-header">4.安装调试记录/博客建站记录_hiker</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">windows环境下使用hexo搭建hiker博客记录搭建步骤
购买域名

github创建个人仓库

安装node.js

安装hexo

推送网站

域名解析

更换主题

更改配置

发布文章

使用图床


1.域名购买godaddy.com: 域名很全但价格较高，首年年费均价￥60左右,往后每年续费￥120左右。
阿里云：价格适中但个性化后缀较少,cc后缀域名无法备案
namesilo.com: 域名较全,价格最低,bqlab.cc十年￥280,最终在此购买。 
在namesilo.com中的Domain manager中将域名DNS服务器修改为：

ns1.alidns.com
ns2.alidns.com
2.github创建仓库仓库名命名为fuzzypw.github.io，亲测改成其他域名网站不能正常访问，
settings，设置custom domain,输入fuzzy.pw
3.安装node.js下载地址：https://nodejs.org/en/download/
安装完成后检测是否成功：node -v
检测npm是否一起安装成功: npm - v
4.安装h</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-27&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/2.%E6%AF%94%E8%B5%9B/%E6%8C%87%E5%AF%BC_%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87&%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9&%E8%B6%85%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/">
        <p class="h4 index-header">2.比赛/指导_性能指标&amp;模型选择&amp;超参数设置</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">性能指标 &amp; 模型选择 &amp; 超参数设置已经知道了常用的模型和训练方法。本文主要记录实际应用中对应特定场景选择哪种模型、如何通过收集模型的反馈结果改善模型。
有时候并不需要采用最新最复杂的模型，而是深入理解一些通用的模型，并更好的实际应用到我们处理的具体问题上去。
（和健身同理，卧推后加夹胸超级组、肩推往头顶夹等高端技巧，但训练效果不好；基础动作（屈伸）练扎实，改善基本问题（脊椎旋转、肩胛骨不稳）后，做简单的推肩10kg和侧平举2kg都觉得酸的要死）。
XLM-R就是fancy的训练技巧，基本的LSTM等理解透彻就是基本功扎实后的简单动作。
孰优孰劣pretty obvious
性能指标准确率与召回率
例如罕见病识别问题，我们只需要设计一个模型将所有的样本的结果都判定为“否”，就可以得到99.99%的准确率，但是无意义。于是在不同的场景下对模型的性能指标有不同定义。
准确率与召回率是两个重要的性能指标。
其中准确率 真正例 / (真正例 + 假正例)是模型作出正例判断时的正确率
召回率是 真正例 / (真正例 + 假反例) 是对于所有实际上正确的例，模型检测到的比率
通常</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/2.%E6%AF%94%E8%B5%9B/%E6%8C%87%E5%AF%BC_%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/">
        <p class="h4 index-header">2.比赛/指导_特征提取与特征选择</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">特征提取与特征选择这两者的效果是一样的，都是试图去减少特征数据集中的属性（特征）的数目，但是两者采用的方法不同，
特征提取的方法是通过属性之间的关系，通过组合不同的属性得到新的属性，改变了特征空间
特征选择的方法是选择出特征集的子集，是一种包含的关系，没有改变特征空间
1.2特征提取的主要方法PCA,LDA,SVD等
1.3特征选择的主要方法1.fliter方法
对每个特征打分，即给出每一维的特征赋予权重，该权重代表了特征的重要性，然后根据权重排序。
主要的方法：卡方，信息增益，相关系数
2.Wrapper方法
主要思想：将子集的选择看成一个搜索寻优问题，生成不同的组合，对组合进行评论
可看做一个优化问题，有很多优化算法可供使用
尤其是启发式算法GA，PSO,DE,ABC等等
主要方法：递归特征消除方法
3.Embedded方法
主要思想：在模型既定的情况下，学习出对提高模型准确性最好的属性，即在确定模型的过程中，挑选出哪些对模型训练有重要意义的属性
主要方法：正则化，如岭回归就是在回归的基础上加上了正则化项
1.4总结1.特征提取是从杂乱无章的世界中，去到更高的世界俯瞰原有世界，这时</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/25/0.%E6%A6%82%E5%BF%B5/%E6%8A%80%E6%9C%AF_Storm/">
        <p class="h4 index-header">0.概念/技术_Storm</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Stormstorm是一个Apache顶级开源项目,用于流计算
流式计算

实时获取/传输/计算/展示数据
代表技术:Flume实时获取,KAFKA实时存储,Storm实时计算,Redis实时缓存,mysql实时存储

批计算

批量获取/传输数据
代表技术:sqoop导入数据,HDFS存储数据,MapReduce计算数据,Hive计算数据

storm和hadoop的区别:

storm用于流计算,数据用网络传进来,处理过的数据放在内存中
hadoop用于批计算,处理的数据保存在文件存放系统中

storm和hadoop的相同点:

编程模型类似
storm                     hadoop
Nimbus                JobTracker
Supervisor         TaskTracker
Worker                  child
topology              job
spout/bolt           mapper/reducer



</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-25&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/19/0.%E6%A6%82%E5%BF%B5/NLP_GRU/">
        <p class="h4 index-header">0.概念/NLP_GRU</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Gated RNN : GRULSTM和GRU这两个重要的深度学习模型，几乎所有能看到的所有深度学习论文都是以这两个模型为基础。
GRU模型GRU模型的主要思想是，我们希望能够保存一些记忆，能够捕获一些较长的依赖，需要有一个模型去学习何时以及如何去做，同时还得允许错误消息流转。基于输入，这些流转会向不同的方向以不同的强度传递。
对GRU的介绍从标准的RNN开始
循环神经网络RNN基本上直接计算下一步的隐层，同样的，之前的隐状态会回归给向量，我们不是去计算GRU数值，而是先要计算其中各个门，这些门和h(t)一样，就是一些连续的隐状态长度一致的向量。这些门包括更新门和重置门。
计算更新门时主要是基于当前输入的词向量和隐藏状态

计算重置门方法类似但是使用的是不同的权重

通过一个直观例子来认识重置门的作用：

详细分析上图的公式和重置门的作用：假如这是一个语义的情感分析任务，前边都是对一个电影长篇累牍的剧情讨论，最后一句话是it`s a really boring movie.那么其实只要最后这个boring就OK了，前边的都可以舍弃。所以这里重置门就可以置为0，把计算累计的东西都清理掉，</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-19&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/19/0.%E6%A6%82%E5%BF%B5/NLP_LSTM/">
        <p class="h4 index-header">0.概念/NLP_LSTM</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">LSTMLSTM是什么？GRU可以在序列中学习较长的序列连接，另一种允许你很好的处理长距离序列连接的模型就是LSTM—长短时记忆单元，这个模型比GRU更加强大。
LSTM原始论文中采取了大量的篇幅来分析梯度消失的原因，吴恩达不建议读原始论文来了解LSTM的细节。
控制LSTM行为的核心等式

ct，at是维持的状态值（时时更新），u，f，o分别是更新门，遗忘门，输出门。
LSTM的内部结构图：

Runtime LSTM结构图：

如上的红线表示了通过适当地设置了更新们和遗忘门后，一些数据可以长效地被记住的过程。（从左到右一直被维持着。）
朴素RNN与展开是一种处理序列数据的神经网络，某单词根据上下文变化而有不同含义这种任务就适合交给RNN来做。

RNN在时序上展开

LSTM与RNN结构对比长短期记忆（Long short-term memory, LSTM）是一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。
LSTM结构和普通RNN的对比图如下，LSTM有两个传输状态，分别是cell</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-19&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/18/0.%E6%A6%82%E5%BF%B5/NLP_RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">
        <p class="h4 index-header">0.概念/NLP_RNN循环神经网络</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">循环神经网络RNN循环神经网络擅长处理序列化的数据，比如文字序列或者时间序列。
循环神经网络比基本的前馈神经网络强在它可以跨时间序列地共享不同输入序列之间的特征。
之前提到的CNN卷积神经网络也可参数共享，而RNN循环神经网络与之不同的是每一点的输出依赖于之前的结果。
状态机近似表示RNN名字中的recurrent得名于如下图所示的t时刻的状态 依赖于 t - 1时刻的状态 + 输入x。

​              ↑总图                   ↑拆分                                 ↑ t - 1时刻            ↑ t时刻               ↑ t + 1时刻
上图维持的状态h(t)可以看作是之前的向量序列【x1，x2，x3，x4，……，xn】的全体有损表示（损度可控，某些语言模型只有附近的文字重要就可以加大损度）。
RNN基本结构图
如上，x是时时输入的序列，h是维持的状态，o是状态给出的输出，y是训练集中的答案，L是答案和输出之间的损失函数（如交叉熵）。
因为上一个状态h(t-1)和下一个状态ht之间有循环连</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-18&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/17/3.%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_%E6%AD%A3%E4%BA%A4%E5%BD%92%E4%B8%80%E6%80%A7/">
        <p class="h4 index-header">3.课程/线性代数_正交归一性</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">正交归一性如果内积空间的两个向量是互相正交的，并且两个向量的范数都是1，则称这两个向量互相具有正交归一性/正交规范性。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-17&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/17/3.%E8%AF%BE%E7%A8%8B/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_%E5%BD%92%E4%B8%80%E5%8C%96/">
        <p class="h4 index-header">3.课程/线性代数_归一化</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">归一化归一化消除了量纲，是处理数据的一种手段。通过归一化最优解的寻找过程会变得平缓，更容易正确的收敛到最优解。
下图的例子是房价预测模型，横坐标是房间数量（0 - 10），纵坐标是面积大小（0 - 1000），预测结果是等高线上的没画出的第三维。
图一未归一化，图像是长椭圆，图二归一化后是正圆（拍扁了数据），可见归一化后收敛过程更平缓。


</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-17&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/15/0.%E6%96%87%E7%AB%A0/NLP_The%20Annotated%20Transformer/">
        <p class="h4 index-header">0.文章/NLP_The Annotated Transformer</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">The Annotated Transformerharvard nlp 对Transformer论文的逐行注解,原文：http://nlp.seas.harvard.edu/2018/04/03/attention.html
本文在github和谷歌drive上的网址：
https://github.com/harvardnlp/annotated-transformer
https://drive.google.com/file/d/1xQXSv6mtAOLXxEMi8RvaW8TW-7bvYBDF/view
Import lib:import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import math, copy, time
from torch.autograd import Variable
import matplotlib.pyplot as plt
import seaborn
seaborn.set_context(context=&quot;ta</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-15&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/15/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_WordEmbedding%E8%AF%A6%E8%A7%A3/">
        <p class="h4 index-header">0.概念/NLP_词向量_WordEmbedding详解</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Word_embedding独热码的缺点：
它只考虑了单个单词在向量中的作用，而没有考虑词语与词语之间的关系。
如下，有一个训练好的语言模型，要对“I want a glass of orange  ____”进行识别，并预测接下来的词，那么独热码就不能知道apple 和 orange之间的词义相近性，于是不能在算法习得了I want a glass of orange juice之后，泛化地预测 I want a glass of apple juice，这是因为orange和apple在独热码中的编码是完全随机的，并没有因为词性相近就结构也相近，456和6257的位置并没有章法（随机或者按照词频分布），并且由于独热码的结构特殊性，任何两个独热向量相乘的结果都是0。
特征化表示：
所以自然地，我们使用这些词的特征化表示，比如把性别作为一个维度来度量这些词，男的是-1，女的是1，然后king就可以是-0.95,queen就是0.97，橘子和苹果就是基本性别中性的词。另一个维度是有多高贵，明显king和queen是高贵的词而apple和orange的高贵属性为接近0的数字。

如下是对词</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-15&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/14/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_SkipGram/">
        <p class="h4 index-header">0.概念/NLP_词向量_SkipGram</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">skip-gram算法详解Skip-gram算法是word2vec模型中两大生成词向量算法中的一个。
生成词汇向量的skip-gram算法的中心思想：给定中心词汇，预测单词们出现在它周围的概率，最终确定的这些单词们，要使概率分布值最大化。
如下，中心词是banking，Skip - gram会尝试去预测它一定范围内（m window）的上下文词汇。

Skip-gram的损失函数损失函数J`(θ)表示的是：一串很长的文本比如整个维基百科（which has足够长的词汇序列和足够多的词汇和真正的行文）然后遍历文本中的所有位置，对于每个位置，我们都会定义一个围绕输入词汇的大小为2m的窗口，窗口包括前后各m个单词，把每个词汇和周围的窗口的p(周围每一个词|中心词)都连乘起来。
这就是一个有监督学习，目标是使损失函数最小化，手段是通过对训练集的training动态调整模型的超参数们(窗口大小，容差系数等).

损失函数plus : 计算机中大量连乘容易误差累计和误差消失，给上边的损失函数整体套上log，将连乘转换为带log的连加。如下
要不是高中学的明白根本肝不到这里……answer the </div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-14&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/13/0.%E6%96%87%E7%AB%A0/NLP_word2vec%E5%BA%94%E7%94%A8/">
        <p class="h4 index-header">0.文章/NLP_word2vec应用</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">word2vec应用读取数据import pandas as pd

# Read data from files 
train = pd.read_csv( &quot;labeledTrainData.tsv&quot;, header=0, 
 delimiter=&quot;\t&quot;, quoting=3 )
test = pd.read_csv( &quot;testData.tsv&quot;, header=0, delimiter=&quot;\t&quot;, quoting=3 )
unlabeled_train = pd.read_csv( &quot;unlabeledTrainData.tsv&quot;, header=0, 
 delimiter=&quot;\t&quot;, quoting=3 )

# Verify the number of reviews that were read (100,000 in total)
print (&quot;Read %d labeled train reviews, %d labeled test</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-13&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/">
        <p class="h4 index-header">0.概念/NLP_神经网络和反向传播算法</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">神经网络神经网络深入学习的网站：neuralnetworksanddeeplearning.com 
神经网络就是一个函数，本例中有764个输入，有10个输出 
总览图:
第一层(764)：
764个输入源于28 * 28的正方形格子，每个小格子都是0到1之间的值，越接近1就越白，越接近0就越黑。
隐藏层
隐藏层是干什么的？ 大体上说，隐藏层用于发掘模式。如上所示，隐藏层一识别小线段，隐藏层二识别小线段构成层的圈或者大线段
从这里看出深度神经网络其实就是模式识别的高级应用，所以要恶补pattern recognition。
如何训练神经网络？ 训练神经网络就是把训练集中的数据和label在神经网络中的(784 * 16 + 16 * 16 + 16 * 10) + (16+16+10) =13002    个参数通过动态调整来拟合。
从数学上来说，动态调整13002个参数以获得min(代价函数)的做法，本质上就是寻找函数的最小值，如下

w1和a1： 
a1就是输入的784个点中第一个点的亮暗情况
w1就是接受这第一个点a1刺激的第一层的第一个神经元对第二层的如图所示的神经元的兴奋程度</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/">
        <p class="h4 index-header">0.概念/NLP_随机森林</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">随机森林随机森林就是用随机的方法建立一堆决策树。每棵树之间是没有关联的，当一个待分类样本输入森林中时，将此样本输入进每一个决策树然后看哪种分类结果最多，就最终输出哪种分类结果。
随机森林的构造过程：

假设有N个样本，有放回的随机选择N个样本，然后按照这N个样本训练一个决策树，这N个样本就是决策树根节点的样本
当每个样本有M个属性时，就需要在决策树中分裂节点以做进一步的判断。于是从M中随机选出m个(m &lt;&lt; M)个属性，然后从m个属性中采取某种策略（比如min信息熵）来选择一个属性来作为该节点的分裂属性。
然后就是重复上边的步骤。当下一次分裂选出来的属性还是父节点的属性时，说明已经穷尽属性，到达叶子节点。

按照如上三个步骤，可以构造大量决策树，例如movie sentiment tutor step1中的随机森林就是构造了100颗决策树。
注意：随机森林中的决策树并没有为了回避过拟合问题而剪枝，因为随机采样已经避免了过拟合。
此算法优点：

数据上表现好，两个随机性的引入避免了过拟合问题
抗噪声
能处理高维度数据，而且不用做特征选择。
对数据集的适应能力强，既能处理连续性</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E5%86%B3%E7%AD%96%E6%A0%91/">
        <p class="h4 index-header">0.概念/NLP_决策树</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">决策树决策树是一种树形结构分类器。每个节点都有一个表示属性的判断，每个分支都代表了一个判断结果的输出。
常见的决策树生成算法有ID3,C4.5,C5.0,CART等。
示例：如下图片是正确的分类集（train set）

如下是分类树的判断过程（演示了分类树其实可以有不同构型）


如上分类树的根节点都是判断分数是否大于A（90），如果是就是好学生。然后第二个节点就出现了不同，分别是判断分数是否小于70 OR 出勤率是否大于0.8。
这个分类器节点的构造其实很灵活，怎样构造最好的分类器呢？ID3,ID4.5算法都是倾向于迭代选择熵值最小化的那个分类器。但是ID3,ID4.5算法都有严重的过拟合问题。
CART算法也使用了类似熵的指数–GINI指数，CART算法迭代的目标也是向着GINI指数最小化的方向进行，不过CART算法为了解决过拟合的问题，使用了剪枝的策略，也就是将树中过长的枝叶剪去。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/12/0.%E6%A6%82%E5%BF%B5/NLP_%E8%AF%8D%E5%90%91%E9%87%8F_%E8%AF%8D%E8%A2%8BBOW/">
        <p class="h4 index-header">0.概念/NLP_词向量_词袋BOW</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">词袋算法详解词袋算法是word2vec中构建两大构建词向量算法中的一个。
kaggle tutor实战解读：具体操作如下：

清洗整个语料库by美丽汤
去掉停止词和非英语单词，去掉数组，大小写统一by正则表达式
将剩下的单词组成词典
词典按照词频降序排列
然后指定词袋的feature个数，以五千为例就是前5000个常用单词作为每一个词语/句子的向量表示。
每个向量都是5000维，第一维就是最常用的单词，第二维就是第二常用的单词，第一维是1说明被本向量表示的句子中最常用的单词出现了一次，第一维是2说明被表示的句子中最常用的单词出现了两次。


然后可以将例如25000条语料依次分别按照5000维的向量表示，集合到shape(25000 * 5000)的矩阵中

然后此矩阵带上label就可以用来训练model了
CS224N解读词袋的训练模型如下。

输入层：上下文的独热码，假设向量空间V维，上下文单词个数是C。

所有onehot分别乘以共享的W（V*N）初始化权重矩阵，V是向量维度，N自己设置。

因为是onehot向量，只有一个值为1，其他都是0，所以乘以权重矩阵后仍然是向量，然后</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-12&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/08/0.%E6%96%87%E7%AB%A0/NLP_%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8/">
        <p class="h4 index-header">0.文章/NLP_词袋模型应用</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">词袋模型的应用1.引入训练数据
import pandas as pd
train = pd.read_csv(&quot;labeledTrainData.tsv&quot;, header=0,delimiter=&quot;\t&quot;, quoting=3)
2.确定引入数据是否正确 – 看一下shape和列标签
&gt;&gt;&gt; train.shape
(25000, 3)

&gt;&gt;&gt; train.columns.values
array([id, sentiment, review], dtype=object)
3.glipise
print train[&quot;review&quot;][0]
4.用beautiful soap清洗掉HTML标签
# Import BeautifulSoup into your workspace
from bs4 import BeautifulSoup             

# Initialize the BeautifulSoup object on a single movie revie</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-08&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/07/0.%E6%96%87%E7%AB%A0/NLP_%E4%BB%8EWordEmbedding%E5%88%B0Bert/">
        <p class="h4 index-header">0.文章/NLP_从WordEmbedding到Bert</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">从Word embedding到Bert：A brief history of nlp pre-train modelWord embeddingLM做word embedding –&gt; 使用的工具是word2vec –&gt; word2vec的训练方法：CBOW 和 SKIP - GRAM
word embedding的问题：无法解决一词多义。
​                                                两种不同的上下文信息经过word2vec都会预测相同的单词bank，因为同一个单词占                                                用的是同一行的参数空间。所以WE无法区分一词多义。
ELMO为解决WE一词多义问题，提出ELMO，其思路是事先用LM学好 一个单词的word embedding，后边根据上下文动态调整。WE是静态，ELMO是动态，所以ELMO可以解决一词多义问题。
ELMO工作方式分为两段，分别是利用语言模型进行预训练和做下游任务时将预训练网络中提取对应单词的网络的各层的wor</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-07&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/07/2.%E6%AF%94%E8%B5%9B/Toxic_%E6%80%9D%E8%B7%AF/">
        <p class="h4 index-header">2.比赛/Toxic_思路</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">思路ToDoList







bpe
跨语言编码


XLM-R + ERNIE
kaggle最热跨语言模型 + 注入特定知识toxic


transformer
特征抽取器(模型)要向匹配问题领域的特点去修改


lstm
transformer组件










选择正确的特征抽取器解决情感分类问题，从模型角度讲，最重要的是特征抽取器的能力。以前是研发人员设计抽取哪些特征，现在都是端到端的抽取，也就是特征抽取器Transformer自动抽取。根据今日阅读知乎和github上的观点，不要使用RNN和CNN，应该采用更加先进的Transformer。
</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-07&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/05/07/3.%E8%AF%BE%E7%A8%8B/CS224n_9%20-%20%E6%9C%BA%E7%BF%BB/">
        <p class="h4 index-header">3.课程/CS224n_9 - 机翻</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">机翻对于机器翻译这种任务，你可以抛弃那些考虑规则的想法。情感分析类任务也许可以建立词汇的正面或者负面表格，然后根据这些词汇的词性进一步延伸出其他规则或系统，但是翻译类问题baseline一般都是基于统计的，因为没有人可以遍历一门语言翻译为另一门语言时所有的规则和异常语言。
我们总是倾向于使用相当庞大的语料库，我们通常称为平行语料库。在平行语料库中，很多相同的段落平行地以多种语言表达。最经典的平行语料库应该就是圣经了。
基于统计的机翻模型介绍
源语言是法语，目标语言是英语，利用贝叶斯准则的概率公式,也就是后验概率 = 显先验概率*似然，然后除以边缘概率。这里的边缘概率可以是源语言。其中p(f|e)是翻译模型，p(e)是语言模型，语言模型也就是我们试图计算更长序列概率的那个模型。

如下是机器翻译模型的工作流程：首先翻译模型会把一个法语句子基于统计列出一系列可能的英语选项。然后使用语言模型，在这些选项里找一个简单流畅的句子。

其中的一个模块，翻译模型中，第一件要做的事情是匹配两种语言的单词，匹配所面临的困难使用法语英语互译来展示。其实英法是相似度很高的语言，换成其他相似度低的语言则难度会</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-05-07&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>

  <div class="row mb-4 mx-auto">
    
    
    <div class="col-12 col-md-8 m-auto">
      <a href="/2020/04/28/3.%E8%AF%BE%E7%A8%8B/CS224u_Sentiment_Analysis_%E6%9C%89%E7%9B%91%E7%9D%A3%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90.md/">
        <p class="h4 index-header">3.课程/CS224u_Sentiment_Analysis_有监督的情感分析.md</p>
        
        
          
        
        <div class="index-excerpt" >
          <div class="index-text mb-1">Sentiment_Analysis_有监督的情感分析.md
如上所示，phi函数就是上篇介绍的feature function，提供的功能就是把tree转换成字典。

如上所示，fit model函数提供将数据x和y fit进指定模型（逻辑回归）中的功能。

然后使用上节介绍的sst.experiment函数（三个参数）分别是路径，feature函数和fit函数。
这样设计的好处就是实现了类的分离，如果需要改写feature函数或者fit函数，直接在本体里边修改就好。
超参数的搜索与确定超参数的基本原理：超参数是模型的优化过程之外的“settings”。有如下几个例子：

超参数搜索实例

如上，In[4] 的 fit_softmax_with_crossvalidation函数，就是搜索超参数的函数。basemod是逻辑回归，给他加上了搜索空间：c,罚函数，等，然后调用系统工具箱里的utils.fit_classifier_with_crossvalidation就可以得到搜索结果。当然这个搜索的过程耗时较长。
然后把得到的函数放进experiment函数中开始实验。因为得到的函数</div>
        </div>
      </a>

      <div>
        
          <i class="iconfont icon-riqi2"></i>&nbsp;2020-04-28&nbsp;&nbsp;
        
        
        
      </div>
    </div>
  </div>



  <nav aria-label="index posts navigation">
    <span class="pagination pg-blue justify-content-center mt-5" id="pagination">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-double-right"></i></a>
    </span>
  </nav>
  
  <script>
    for (ele of document.getElementById("pagination").getElementsByClassName("page-number")) {
      ele.href += '#board';
    }
  </script>



              </div>
            </div>
          </div>
        </div>
      </div>
    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>






  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "暗影疾行&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 120,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
